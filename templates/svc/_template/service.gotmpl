// this file is generated by servgen util based on a template at 2021-06-26 10:37:24 +0300 MSK
package {{.service.name}}

import (
	"context"
	"github.com/travelata/kit/monitoring"
	"github.com/travelata/kit/queue"
	"github.com/travelata/kit/queue/stan"
	"github.com/travelata/kit/service"
	"github.com/travelata/{{.service.name}}/config"
	"github.com/travelata/{{.service.name}}/domain"
	"github.com/travelata/{{.service.name}}/domain/impl"
	"github.com/travelata/{{.service.name}}/grpc"
	"github.com/travelata/{{.service.name}}/logger"
	"github.com/travelata/{{.service.name}}/meta"
	"github.com/travelata/{{.service.name}}/repository/adapters/another"
	"github.com/travelata/{{.service.name}}/repository/storage"
)

// serviceImpl implements a service bootstrapping
// all dependencies between layers must be specified here
type serviceImpl struct {
	service.Cluster
	cfg                   *config.Config
	monitoring            monitoring.MetricsServer
	sampleService         domain.SampleService
	grpc                  *grpc.Server
	storageAdapter        storage.Adapter
	anotherServiceAdapter another.Adapter
	queue                 queue.Queue
}

// New creates a new instance of the service
func New() service.Service {

	s := &serviceImpl{
		Cluster:    service.NewCluster(logger.LF(), meta.Meta),
		monitoring: monitoring.NewMetricsServer(logger.LF()),
	}

	s.queue = stan.New(logger.LF())
	s.storageAdapter = storage.NewAdapter()
	s.anotherServiceAdapter = another.NewAdapter()

	s.sampleService = impl.NewSampleService(s.storageAdapter, s.anotherServiceAdapter, s.queue)

	s.grpc = grpc.New(s.sampleService)

	return s
}

func (s *serviceImpl) GetCode() string {
	return meta.Meta.ServiceCode()
}

// Init does all initializations
func (s *serviceImpl) Init(ctx context.Context) error {

	// load config
	var err error
	s.cfg, err = config.Load()
	if err != nil {
		return err
	}

	// set log config
    logger.Logger.Init(s.cfg.Log)

	// init cluster
	if err := s.Cluster.Init(s.cfg.Cluster, s.cfg.Nats.Host, s.cfg.Nats.Port, s.onClusterLeaderChanged(ctx)); err != nil {
		return err
	}

	// init storage
	if err := s.storageAdapter.Init(s.cfg.Storages); err != nil {
		return err
	}

	// another service adapter
	if err := s.anotherServiceAdapter.Init(s.cfg.Adapters["another"]); err != nil {
		return err
	}

	// init grpc server
	if err := s.grpc.Init(s.cfg.Grpc); err != nil {
		return err
	}

	// open Queue connection
	if err := s.queue.Open(ctx, meta.Meta.InstanceId(), s.cfg.Nats); err != nil {
		return err
	}

	// init monitoring
	if s.cfg.Monitoring.Enabled {
		if err := s.monitoring.Init(s.cfg.Monitoring); err != nil {
			return err
		}
	}

	return nil

}

func (s *serviceImpl) onClusterLeaderChanged(ctx context.Context) service.OnLeaderChangedEvent {

	// if the current node is getting a leader, run daemons
	return func(l bool) {
		if l {
			// do something if the node is turned into a leader
			logger.L().C(ctx).Cmp("cluster").Mth("on-leader-change").Dbg("leader")
		}
	}

}

func (s *serviceImpl) Start(ctx context.Context) error {

	// start cluster
	if err := s.Cluster.Start(); err != nil {
		return err
	}

	// serve gRPC connection
	s.grpc.ListenAsync()

	// listen for scraping metrics
	if s.cfg.Monitoring.Enabled {
		s.monitoring.Listen()
	}

	return nil
}

func (s *serviceImpl) Close(ctx context.Context) {
	s.Cluster.Close()
	s.anotherServiceAdapter.Close()
	_ = s.queue.Close()
	s.storageAdapter.Close()
	s.grpc.Close()
	if s.cfg.Monitoring.Enabled {
		s.monitoring.Close()
	}
}
