// this file is generated by servgen util based on a template at 2021-06-15 16:34:00 +0300 MSK
package storage

import (
	"context"
	"encoding/json"
	"github.com/go-redis/redis"
	"github.com/olivere/elastic/v7"
	"github.com/travelata/kit/common"
	kitDb "github.com/travelata/kit/db"
	"github.com/travelata/kit/log"
	"github.com/travelata/{{.service.name}}/domain"
	"github.com/travelata/{{.service.name}}/errors"
	"github.com/travelata/{{.service.name}}/logger"
	"math"
	"time"
)

const (
	CacheKeySampleId = "sample.id:"
	IndexSample      = "samples"
)

// sample is DB model
type sample struct {
	kitDb.BaseDto
	Id      string `gorm:"column:id"`
	Name    string `gorm:"column:name"`
	Details string `gorm:"column:details"`
}

// iSample is ES index model
type iSample struct {
	Name    string `json:"name" es:"type:text"`
	Deleted bool   `json:"deleted" es:"type:boolean"`
}

func (a *adapterImpl) l() log.CLogger {
	return logger.L().Cmp("{{.service.name}}-storage")
}

func (a *adapterImpl) ensureSampleIndex() error {
	return a.container.Search.CreateIndexIfNotExistWithModel(IndexSample, &iSample{})
}

func (a *adapterImpl) setSampleCacheAsync(ctx context.Context, dto sample) {

	go func() {

		l := a.l().Mth("set-cache").C(ctx).Dbg()

		keyId := CacheKeySampleId + dto.Id

		j, err := json.Marshal(dto)
		if err != nil {
			l.E(err).St().Err()
		}
		dtoStr := string(j)

		// set cache for id key
		if err := a.container.Cache.Instance.Set(keyId, dtoStr, time.Hour).Err(); err != nil {
			l.E(errors.ErrSampleStorageSetCache(err, ctx, dto.Id)).St().Err()
		}
	}()
}

func (a *adapterImpl) CreateSample(ctx context.Context, sample *domain.Sample) error {
	a.l().C(ctx).Mth("create")
	// save to DB
	if err := a.container.Db.Instance.Create(a.toSampleDto(sample)).Error; err != nil {
		return errors.ErrSampleStorageCreate(err, ctx)
	}
	// indexing
	a.container.Search.IndexAsync(IndexSample, sample.Id, a.toSampleIndex(sample))
	return nil
}

func (a *adapterImpl) GetSample(ctx context.Context, id string) (bool, *domain.Sample, error) {
	l := a.l().Mth("get").C(ctx).F(log.FF{"id": id}).Dbg()

	key := CacheKeySampleId + id
	if j, err := a.container.Cache.Instance.Get(key).Result(); err == nil {
		// found in cache
		l.Dbg("found in cache")
		dto := &sample{}
		if err := json.Unmarshal([]byte(j), &dto); err != nil {
			return true, nil, err
		}
		return true, a.toSampleDomain(dto), nil
	} else {
		if err == redis.Nil {
			// not found in cache
			dto := &sample{Id: id}
			if res := a.container.Db.Instance.Limit(1).Find(&dto); res.Error == nil {
				l.DbgF("db: found %d", res.RowsAffected)
				if res.RowsAffected == 0 {
					return false, nil, nil
				} else {
					// set cache async
					a.setSampleCacheAsync(ctx, *dto)
					return true, a.toSampleDomain(dto), nil
				}
			} else {
				return false, nil, errors.ErrSampleStorageGetDb(res.Error, ctx, id)
			}

		} else {
			return false, nil, errors.ErrSampleStorageGetCache(err, ctx, id)
		}
	}
}

func (a *adapterImpl) UpdateSample(ctx context.Context, sample *domain.Sample) error {
	a.l().Mth("update").C(ctx).Dbg()

	// update DB
	if err := a.container.Db.Instance.Save(a.toSampleDto(sample)).Error; err != nil {
		return errors.ErrSampleStorageUpdate(err, ctx, sample.Id)
	}

	// clear cache
	keys := []string{CacheKeySampleId + sample.Id}
	a.container.Cache.Instance.Del(keys...)

	// indexing
	a.container.Search.IndexAsync(IndexSample, sample.Id, a.toSampleIndex(sample))

	return nil
}

func (a *adapterImpl) getSamplesByIds(ctx context.Context, ids []string) ([]*domain.Sample, error) {
	a.l().Mth("get-ids").C(ctx).Dbg()

	// if one requested, redirect to Get
	if len(ids) == 0 {
		_, sample, err := a.GetSample(ctx, ids[0])
		return []*domain.Sample{sample}, err
	} else {
		var samples []*sample
		err := a.container.Db.Instance.Find(&samples, ids).Error
		if err != nil {
			return nil, errors.ErrSampleStorageGetIds(err, ctx)
		}
		return a.toSamplesDomain(samples), nil
	}
}

func (a *adapterImpl) SearchSamples(ctx context.Context, cr *domain.SearchCriteria) (*domain.SearchResponse, error) {
	a.l().C(ctx).Mth("search").Dbg()

	response := &domain.SearchResponse{
		PagingResponse: &common.PagingResponse{},
		Samples:        []*domain.Sample{},
	}

	cl := a.container.Search.GetClient()

	bq := elastic.NewBoolQuery()

	var filters []elastic.Query
	var matches []elastic.Query

	if cr.Name != "" {
		matches = append(matches, elastic.NewMatchQuery("name", cr.Name))
	}

	if len(matches) > 0 {
		bq = bq.Must(matches...)
	} else {
		bq = bq.Must(elastic.NewMatchAllQuery())
	}

	filters = append(filters, elastic.NewTermQuery("deleted", "false"))

	// paging
	from := (cr.Index - 1) * cr.Size
	if from < 0 {
		from = 0
	}

	bq = bq.Filter(filters...)
	sr, err := cl.Search(IndexSample).
		Query(bq).
		From(from).
		Size(cr.Size).
		Do(ctx)
	if err != nil {
		return nil, errors.ErrSampleIndexSearch(err, ctx)
	}

	var ids []string

	if sr.TotalHits() > 0 {
		for _, sh := range sr.Hits.Hits {
			ids = append(ids, sh.Id)
		}
	}

	response.PagingResponse.Total = int(math.Ceil(float64(sr.TotalHits()) / float64(cr.Size)))
	response.PagingResponse.Index = cr.Index

	if len(ids) > 0 {
		response.Samples, err = a.getSamplesByIds(ctx, ids)
		if err != nil {
			return nil, err
		}
	}

	a.l().TrcF("index: %d, db: %d", len(ids), len(response.Samples))

	return response, nil
}
